def label_enocder(data, list_cat_cols):
    '''
    Apply Label encoder to the categorical columns  in data
    
    '''
    
    #Create Label Encoder 
    for column_name in list_cat_cols:
        #Apply label encoder to each column
        le = preprocessing.LabelEncoder()
        data[column_name + 'NEW'] = preprocessing.LabelEncoder().fit_transform(data[column_name])
        
    return data
    
    
def open_csv_create_models(path):
    '''takes in a path, opens corresponding csv files
    
    prepares data and creates model for each bus line/csv
    
    '''
    #declare the columns to be deleted
    cols_to_delete = ['TRIPID','LINEID','ROUTEID']
    #declare continous and cat cols
    cat_cols = ['DelayedArr', 'DelayedDep', 'weather_main']
    numeric = ['JourneyTime','temp','humidity','wind_speed','rain_1h','clouds_all','DIRECTION']
   

    
    #open each file
    for filename in glob.glob(os.path.join(path, '*.csv')):
        with open(os.path.join(path, filename), 'r') as file: 
            bus_line=(filename[36:-4])
            print(bus_line, "Starting...")
            
            #read files in as dataframes
            df=pd.read_csv(file)
            
            #delete necessary cols and change to cat or cont
            for col in cols_to_delete:
                del df[col]
            for column in numeric:
                df[column]= df[column].astype('float32')

            for column in cat_cols:   
                 df[column]= df[column].astype('category')

            #create new cols for modelling
            df['Dates']=df['Dates'].apply(pd.to_datetime)
            df['Weekday']= df['Dates'].dt.day_name()
            df['Hour']= df['Dates'].dt.hour
            df['Month']= df['Dates'].dt.month
            
           

            df = df.drop(["Dates"], axis = 1)
            df=sklearn.utils.shuffle(df)
            cols_to_encode=['weather_main','DelayedArr','DelayedDep','Weekday']
            df =  label_enocder(df, cols_to_encode)

            df_modelling = df.drop(['DelayedArr','DelayedDep','Weekday','weather_main'],axis=1)

            cols=['Hour','DIRECTION','Month']
            for column in cols:
                df_modelling[column]= df_modelling[column].astype('int32')

            # y is the target
            y = df_modelling["JourneyTime"]
            # X is everything else
            X = df_modelling.drop(["JourneyTime"],1)
            # Split the dataset into two datasets: 70% training and 30% test
            X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=1,  test_size=0.3)

            print("Dataset range: ",df_modelling.shape[0])
            print("Train range (70%):\t rows 0 to", round(X_train.shape[0]))
            print("Test range (30%): \t rows", round(X_train.shape[0]), "to", round(X_train.shape[0]) + X_test.shape[0])
      
            model = XGBRegressor().fit(X_train, y_train)
            
            xgb_train_predictions = model.predict(X_train)
            #get predictions on test set
            XGB_predictions_test = model.predict(X_test)

            #get results
            print("MAE_TRAIN", metrics.mean_absolute_error(y_train, xgb_train_predictions))
            mae.append(metrics.mean_absolute_error(y_test, XGB_predictions_test))
            print("MSE",metrics.mean_squared_error(y_test, XGB_predictions_test))
            print("RMSE",np.sqrt(metrics.mean_squared_error(y_test, XGB_predictions_test)))
            r2.append(metrics.r2_score(y_test, XGB_predictions_test))
            print("MPE",np.mean((y_test - XGB_predictions_test)/y_test))
            
            
          
            with open(bus_line, "wb") as f:
                pickle.dump(model, f)
            print(bus_line, "Done.")

